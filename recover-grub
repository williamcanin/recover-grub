#!/bin/bash

appname="Recover Grub"
appscript="recover-grub"
version="2.0.0"
PS3="Enter option: "
dir_mount="/mnt/temp"
name_crypto_open="filesystem"
crypto_type="crypto_LUKS"


# Utils
function _msg_header_() {
  printf "\e[0;36m→ %s\e[0m$2" "$1"
}

function _msg_reply_() {
  printf "\e[0;36m→ %s\e[0m$2" "$1"
}

function _msg_finish_() {
  printf "\e[0;32m✔ %s\e[0m\n" "$@"
}

function _msg_warning_() {
  printf "\e[0;33m⚠ %s\e[0m\n" "$@"
}

function _msg_error_() {
  printf "\e[0;31m✖ %s\e[0m\n" "$@"
}


# Function welcome
function _welcome(){
printf "\e[0;34m

   ---------------------------------------------------------
  |         Welcome - ${appname} - Version ${version}          |
   ---------------------------------------------------------
  | The ${appname} will perform the upgrade and           |
  | installation of Grub in Linux.                          |
  | You will be guided by ${appname} to perform all       |
  | procedures.                                             |
  |---------------------------------------------------------|

\e[0m"
}

# Function show Credits
function _credits(){
cat << EOT

   ---------------------------------------------------------
  |               ${appname} - Version ${version}              |
   ---------------------------------------------------------
  |                         Credits:                        |
  |                                                         |
  |           Author: William da Costa Canin                |
  |           E-Mail: william.costa.canin@gmail.com         |
  |           Website: https://williamcanin.me              |
  |           GitHub: https://github.com/williamcanin       |
  |           Locale: Brazil - SP                           |
  |                                                         |
  |                                                         |
  |    ${appname} © 2015-$(date +%Y) - All Right Reserved.       |
  |    Doc: http://github.com/williamcanin/recover-grub     |
  |---------------------------------------------------------|

EOT
}

# Function show help
function _help(){
cat << EOT

 ---------------------------------------------------------
|           Help  -  ${appname} - Version ${version}         |
 ---------------------------------------------------------

 Usage: $appscript [options]

  Options:

    device            Find the partition where the Arch Linux is mounted
                      and mounts.
                      A list of devices will be displayed, choose the
                      device where the Arch Linux is installed to recover
                      the Grub.

    start             Starts the recovery of Grub.
                      This option is enabled, after the use of the
                      'device' option and assemble the system.

    credits           A list of credits of this program.

    help              Output this instructions.

EOT
}

# Spin function for messages in wait
function _wait_spinner(){
    sleep $1 &
    PID=$!
    i=1
    sp="●◐◒◔◑◓●"
    echo -n ' '
    setterm -cursor off
    printf ' '
    while [ -d /proc/$PID ]
    do
        printf "\b${sp:i++%${#sp}:1}"
    done
    printf "\n"
    setterm -cursor on
}

# Function check if an element exist in a string
function _contains_element() {
    for e in "${@:2}"; do [[ $e == $1 ]] && break; done;
}

# Function to select the partition type. 
function _select_type_partition(){
    _msg_header_ "Select the partition type that the system is installed on:" "\n"
    select type_device in "ext" "${crypto_type}"; do
        if _contains_element "${type_device}" "ext" "${crypto_type}"; then
            break
        else
            printf "Invalid option \n"
        fi
    done
}

# Function to select encrypted partitions (crypto_LUKS).
function _select_mount_partition_crypto(){
    devices_list=( $(blkid | grep "$1" | awk '{print $1}' | cut -d":" -f1) )
    if [[ -n $devices_list ]]; then
        echo
        _msg_header_ "Select one of the encrypted partitions in the list:" "\n"
        select device in "${devices_list[@]}"; do
            if _contains_element "${device}" "${devices_list[@]}"; then
                # Open partition crypted
                echo "cryptsetup open ${device} $3"
                # Mount partition crypted
                echo "mount /dev/mapper/$3 $2"
                break
            else
                printf "Invalid option\n"
            fi
        done
    fi    
}

# Function mount binds
# function _mount_bind(){}

# Function to mount partitions of type EXT recursively.
function _select_mount_partition_ext(){
    devices_list=( $(blkid | grep "$1" | awk '{print $1}' | cut -d":" -f1) )
    for partition in ${devices_list}; do
        sudo mount $partition $2
        if [[ -f "$2/etc/os-release" ]]; then
            distro_name=$(cat $2/etc/os-release | grep ^NAME | cut -d"=" -f2 | cut -d"\"" -f2)
            if [[ "$distro_name" == "Arch Linux" ]] || [[ "$distro_name" == "Manjaro Linux" ]]; then
                printf "Wait" 
                _wait_spinner "5"
                printf "$distro_name device found!\n"
                # exit 0
            else
                umount $2          
            fi
        else
            umount $2       
        fi
    done
}

# Function started mount
function _start_mount(){
    _select_type_partition
    if [[ $type_device == "${crypto_type}" ]]; then
        _select_mount_partition_crypto "${crypto_type}" "${dir_mount}" "${name_crypto_open}"
    else
        _select_mount_partition_ext "ext" "${dir_mount}"
    fi
}

# Function Recover Grub
# function _recover_grub(){
   
#     if [[ -f "${dir_mount}/etc/os-release" ]]; then
#         distro_name=$(cat ${dir_mount}/etc/os-release | grep ^NAME | cut -d"=" -f2 | cut -d"\"" -f2)
#         if [[ "$distro_name" == "Arch Linux" ]]; then

#         fi    
#     fi
# }

_welcome
 _start_mount


# _recover_grub

