#!/usr/bin/env python3

# Information:

# ******************************************************************************
# Type: Python 3
# Description: Mount partition Linux and Recover the Grub on Linux
# Script Name: Recover Grub
# Project URL: https://github.com/williamcanin/recover-grub.git
# URL Script: http://git.io/recover-grub

# Tools used:
#   Atom Editor:
#       - wrap-guide (Preferred Line Lenght: 115)
#       - atom-beautify
#       - autocomplete-python
#       - MagicPython
#       - linter
#       - linter-flake8 (Max Line Length: 115)

# Author: William C. Canin
#   Contacts:
#   E-Mail: william.costa.canin@gmail.com
#   WebSite: https://williamcanin.github.io
#   GitHub: https://github.com/williamcanin

# ******************************************************************************


class RecoverGrub_UI:
    def __init__(self):
        self._header = '\033[36mⓘ  '
        self._warning = '\033[93m⚠  '
        self._reply = '\033[95m→ '
        self._okgreen = '\033[92m✔ '
        self._error = '\033[91m✖ '
        self._end = '\033[0m'

        # Design text using figlet. Install: $ sudo apt install figlet
        # Usage: $ figlet <Text>
        print(f"""
\033[36mWelcome to\033[0m
\033[93m ____                               ____            _
|  _ \ ___  ___ _____   _____ _ __ / ___|_ __ _   _| |__
| |_) / _ \/ __/ _ \ \ / / _ \ '__| |  _| '__| | | | '_ \\
|  _ <  __/ (_| (_) \ V /  __/ |  | |_| | |  | |_| | |_) |
|_| \_\___|\___\___/ \_/ \___|_|   \____|_|   \__,_|_.__/\033[0m
                                       since 2018 © v{self.config['appversion']}
        """)

    def printColor(self, type, color, message, options='') -> str:
        if type == 'print':
            return print(f'{color}{message}' + self._end)
        elif type == 'input':
            return input(f'{color}{message}' + self._end)
        elif type == 'except':
            return print(f'\n{color}{message}' + self._end, options)
        else:
            raise print('Error in first argument in "PrintColor"')


class RecoverGrub_Start:
    def __init__(self):
        print('Ok.')


class RecoverGrub_Engine(RecoverGrub_UI):

    config = {'appname': 'Recover Grub',
              'appscript': 'recover-grub',
              'python_version': 3,
              'modules': ['pyudev', 'tqdm', 'sh'],
              'system': 'OS',
              'appversion': '3.0',
              'mount_dir': '/mnt/temp',
              'name_crypto_open': 'filesystem2',
              'crypto_type': 'crypto_LUKS'
              }

    def modules_external(self, all_packages):
        """
            This function has the purpose of installing dependencies to execute this script through pip.
        """
        from importlib import util
        for item in all_packages:
            spec = util.find_spec(item)
            if spec is None:
                try:
                    import subprocess
                    import sys
                    self.printColor('print', self._header, 'Installing dependencies for ' +
                                    self.config['appname'] + '.' * 3)
                    subprocess.call([sys.executable, "-m", "pip", "install", "--user", item])
                    self.printColor('print', self._okgreen, self.config['appname'] +
                                    ' dependencies installed!\n')
                except Exception as err:
                    self.printColor('except', self._warning, 'There was an error installing the dependencies.',
                                    err)
                    exit(1)
        # return self.printColor('print', self._okgreen, 'All dependencies have been resolved and installed.\n')

    def python_version_required(self, p_version: int):
        """
            Function to check the version of Python that this script uses.
        """
        import sys
        try:
            if sys.version_info[0] < p_version:
                raise Exception('Must be using Python {}'.format(p_version))
        except Exception as err:
            print('Error!', err)
            exit(1)

    def menu_args(self) -> str:
        """
            This function will return the parameters passed in the execution of the script.
        """
        from argparse import ArgumentParser
        try:
            parser = ArgumentParser(prog='prog',
                                    usage='usage',
                                    description='desc')
            parser.add_argument('command', action='store',
                                type=str, default='--help')
            args = parser.parse_args()
            return args

        except Exception as err:
            return self.printColor('except', self._warning, 'Error in passing arguments..', err)

    def get_device(self) -> str:
        """
            A function that returns a list of SD / HS / SSD devices on the machine.
        """
        import pyudev
        context = pyudev.Context()
        for device in context.list_devices(MAJOR='8'):
            if (device.device_type == 'disk'):
                dev_node = device.device_node
                # dev_type = device.device_type
        return dev_node

    def select_device(self) -> str:
        """
            A function that converses with the user to make the selection of the devices of the machine, for
            the assembly.
        """
        # list_devices = ['/dev/sda', '/dev/sdb', '/dev/sdc', '/dev/sdd']  # line test
        list_devices = [self.get_device()]
        self.printColor('print', self._header, 'Select the device in which the Grub will be recovered')

        try:
            while True:
                print()
                for index, item in enumerate(list_devices, start=1):
                    print(f'{index}: {item}')
                index_quit = index + 1
                print(f'{index_quit}: Quit\n')

                choice = self.printColor('input', self._reply, 'Please enter your choice (1-' +
                                         str(index + 1) + '): ')
                # You could use the 'isdigit'.
                # E.g: if not choice.isdigit():
                if not choice.isdigit():
                    self.printColor('print', self._error, 'Enter numbers only')
                    choice_device = None
                    continue
                elif int(choice) == index_quit:
                    self.printColor('print', self._warning, 'Aborted by user')
                    choice_device = None
                    break
                elif int(choice) > (index_quit):
                    self.printColor('print', self._error, 'Option invalid')
                    choice_device = None
                    continue
                else:
                    choice = (int(choice) - 1)
                    choice_device = list_devices[int(choice)]
                    return choice_device
                    break
        except Exception as err:
                return self.printColor('except', self._warning, 'There was some error making the choice.', err)
        except KeyboardInterrupt as ki:
                return self.printColor('except', self._warning, 'Interrupt by user using Ctrl+C.', ki)

    def get_system(self, p_type):
        """
            A function gets an argument to return what type of system the machine is using. If the argument is
            'OS', it will return Windows, Linux or OSX, and the argument is 'distro', it will return the Linux
            distribution being used.
        """
        if p_type.lower() == 'os':
            from sys import platform
            if platform == "linux" or platform == "linux2":
                check_sys = 'linux'
            else:
                self.printColor('print', self._error,
                                'System not compatible with this script. Use only Linux.')
                check_sys = None
                exit(1)
        elif p_type.lower() == 'distro':
            import platform
            check_sys = str(platform.dist()[0])
        else:
            raise Exception('Error check system.')
        return check_sys

    def select_type_partition(self) -> str:
        """
            Select partitions
        """
        self.printColor('print', self._header, 'Select the partition type that the system is installed on:')
        while True:
            try:
                choice = input(f"""
1: Ext3/Ext4
2: {self.config['crypto_type'].title().replace('_', ' (')})
3: Quit

\033[95m→ Please enter your choice (1-3): \033[0m""")

                if choice == "1":
                    type_partition = 'ext'
                    break
                elif choice == "2":
                    type_partition = self.config['crypto_type']
                    break
                elif choice == "3":
                    return self.printColor('print', self._warning, 'Aborted by user.')
                    break
                else:
                    self.printColor('print', self._error, 'Option invalid!')
                    continue
            except Exception as err:
                return self.printColor('except', self._warning, 'Something unexpected happened :(', err)
            except KeyboardInterrupt as ki:
                return self.printColor('except', self._warning, 'Interrupt by user using Ctrl+C.', ki)

        return type_partition

    def mount_partition(self, device_type):
        """
            Function to mount the partition to be recovered by Grub.
        """
        import sh
        from os.path import isfile
        from subprocess import check_output, STDOUT

        try:
            shell_command = '''sudo blkid | grep ''' + device_type + '''| awk '{print $1}' | cut -d":" -f1'''
            devices_output = check_output(shell_command, shell=True, stderr=STDOUT,
                                          universal_newlines=True).splitlines()
        except Exception:
            return None

        if device_type == 'ext':
            for partition in devices_output:
                if isfile(self.config["mount_dir"] + '/etc/os-release'):
                    self.printColor('print', self._warning, 'A mounted partition already exists in ' +
                                    self.config["mount_dir"] + '. Use the "sudo umount ' +
                                    self.config["mount_dir"] + '" command to unmount, and re-run the ' +
                                    self.config["appname"] + '.')
                    break
                else:
                    sh.sudo.mount(partition, self.config["mount_dir"], _fg=True)
                    if isfile(self.config["mount_dir"] + '/etc/os-release'):
                        content_os_release = sh.cat(self.config["mount_dir"] + '/etc/os-release')
                        dict_os_release = dict([i.split('=') for i in content_os_release.strip().split('\n')])
                        distro_name = dict_os_release['NAME'].replace('"', '')
                        distro_pretty_name = dict_os_release['PRETTY_NAME'].replace('"', '')

                        if distro_name == self.get_system('distro'):
                            try:
                                sh.sudo.mount("--bind", "/dev", self.config['mount_dir'] + "/dev", _fg=True)
                                sh.sudo.mount("--bind", "/dev/pts", self.config['mount_dir'] + "/dev/pts",
                                              _fg=True)
                                sh.sudo.mount("--bind", "/proc", self.config['mount_dir'] + "/proc", _fg=True)
                                sh.sudo.mount("--bind", "/sys", self.config['mount_dir'] + "/sys", _fg=True)
                                self.printColor('print', self._okgreen, 'Partition containing "' +
                                                distro_pretty_name + '" was found and mounted on "' +
                                                self.config['mount_dir'] + '".')
                                self.printColor('print', self._warning, 'You are now in the chroot. Run ' +
                                                '\033[36m"recover-grub start"\033[93m to start Grub recovery.')
                                # Enter in Chroot.
                                sh.sudo.chroot(self.config['mount_dir'], "/bin/bash", _fg=True)
                                # Exit chroot.
                                sh.sudo.umount("-R", self.config['mount_dir'], _fg=True)
                            except Exception as err:
                                self.printColor('except', self._warning, 'Error in performing assemblies.', err)
                                sh.sudo.umount("-R", self.config['mount_dir'], _fg=True)
                            break
                        elif distro_name != self.get_system('distro'):
                            sh.sudo.umount(self.config['mount_dir'], _fg=True)
                            continue
                    else:
                        sh.sudo.umount(self.config['mount_dir'], _fg=True)

        elif device_type == self.config['crypto_type']:
            for partition in devices_output:
                if isfile(self.config["mount_dir"] + '/etc/os-release'):
                    self.printColor('print', self._warning, 'A mounted partition already exists in ' +
                                    self.config["mount_dir"] + '. Use the "sudo umount ' +
                                    self.config["mount_dir"] + '" command to unmount, and re-run the ' +
                                    self.config["appname"] + '.')
                    break
                else:
                    # cryptsetup
                    check_output('sudo cryptsetup open ' + partition + ' ' + self.config['name_crypto_open'],
                                 shell=True, stderr=STDOUT, universal_newlines=True)
                    if not isfile(self.config["mount_dir"] + '/etc/os-release'):
                        print('Not system.')

    def main(self):
        """
            Main function that starts the processes.
        """
        # Requeriments
        self.python_version_required(self.config['python_version'])
        self.modules_external(self.config['modules'])
        self.get_system('os')

        # Main
        args = self.menu_args()
        if args.command == 'device':
            self.mount_partition(self.select_type_partition())
            # self.select_device()


if __name__ == '__main__':
    recover_grub = RecoverGrub_Engine()
    recover_grub.main()
