#!/usr/bin/env python3

# Information:
#
# ******************************************************************************
# Type: Python
# Description: Mount partition Linux and Recover the Grub on Linux
# Script Name: Recover Grub
# Project URL: https://github.com/williamcanin/recover-grub.git
# URL Script: http://git.io/recover-grub

# Author: William C. Canin
#   Contacts:
#   E-Mail: william.costa.canin@gmail.com
#   WebSite: https://williamcanin.github.io
#   GitHub: https://github.com/williamcanin


class UI:
    def __init__(self):
        self._header = '\033[36mⓘ  '
        self._warning = '\033[93m⚠  '
        self._reply = '\033[95m→ '
        self._okgreen = '\033[92m✔ '
        self._error = '\033[91m✖ '
        self._end = '\033[0m'

        # Design text using figlet. Install: $ sudo apt install figlet
        # Usage: $ figlet <Text>
        print(f"""
\033[36mWelcome to\033[0m
\033[93m ____                               ____            _
|  _ \ ___  ___ _____   _____ _ __ / ___|_ __ _   _| |__
| |_) / _ \/ __/ _ \ \ / / _ \ '__| |  _| '__| | | | '_ \\
|  _ <  __/ (_| (_) \ V /  __/ |  | |_| | |  | |_| | |_) |
|_| \_\___|\___\___/ \_/ \___|_|   \____|_|   \__,_|_.__/\033[0m
                                              since 2018 ©
        """)

    def printColor(self, type, color, message):
        if type == 'print':
            return print(f'{color}{message}' + self._end)
        elif type == 'input':
            return input(f'{color}{message}' + self._end)
        else:
            print('error')


class Engine(UI):

    """
        Here are some global script variables.
    """
    config = {'appname': 'Recover Grub',
              'appscript': 'recover-grub',
              'python_version': 3,
              'modules': ['pyudev', 'tqdm', 'sh'],
              'system': 'OS',
              'appversion': '3.0',
              'mount_dir': '/mnt/temp',
              'name_crypto_open': 'filesystem',
              'crypto_type': 'crypto_LUKS'
              }

    """
        This function has the purpose of installing dependencies to execute this script through pip.
    """
    def modules_external(self, all_packages):
        from importlib import util
        for item in all_packages:
            spec = util.find_spec(item)
            if spec is None:
                try:
                    import subprocess
                    import sys
                    self.printColor('print', self._header, 'Installing dependencies for ' +
                                    self.config['appname'] + '.' * 3)
                    subprocess.call([sys.executable, "-m", "pip", "install", "--user", item])
                    self.printColor('print', self._okgreen, self.config['appname'] +
                                    ' dependencies installed!\n')
                except Exception as e:
                    print('There was an error installing the dependencies.', e)
                    exit(1)
        # return print('All dependencies have been resolved and installed.')

    """
        Function to check the version of Python that this script uses.
    """
    def python_version_required(self, p_version):
        import sys
        if sys.version_info[0] < p_version:
            raise Exception('Must be using Python {}'.format(p_version))

    """
        This function will return the parameters passed in the execution of the script.
    """
    def menu_args(self):
        from argparse import ArgumentParser
        try:
            parser = ArgumentParser(prog='prog',
                                    usage='usage',
                                    description='desc')
            parser.add_argument('command', action='store',
                                type=str, default='--help')
            args = parser.parse_args()
            return args

        except Exception as err:
            print('Err! Erro na passagem de argumentos.', err)

    """
        A function that returns a list of SD / HS / SSD devices on the machine.
    """
    def get_device(self):
        import pyudev
        context = pyudev.Context()
        for device in context.list_devices(MAJOR='8'):
            if (device.device_type == 'disk'):
                dev_node = device.device_node
                # dev_type = device.device_type
        return dev_node

    """
        A function that converses with the user to make the selection of the devices of the machine, for
        the assembly.
    """
    def select_device(self):
        # list_devices = ['/dev/sda', '/dev/sdb'] # line test
        list_devices = [self.get_device()]
        self.printColor('print', self._header, 'Select the device in which the Grub will be recovered')
        opt = True
        while opt:
            print()
            for index, item in enumerate(list_devices, start=1):
                print(f'{index}: {item}')
            print(f'{index + 1}: Quit\n')

            # choice = input(f'\nPlease enter your choice (1-{index + 1}): ')
            choice = self.printColor('input', self._reply, 'Please enter your choice (1-' +
                                     str(index + 1) + '):')
            choice = int(choice)
            if choice == int(index + 1):
                self.printColor('print', self._warning, 'Aborted by user')
                opt = False
                exit(0)
            elif choice >= int(index + 1):
                self.printColor('print', self._error, 'Option invalid')
                opt = True
            else:
                opt = False
                choice = int(choice) - 1
                choice_device = list_devices[choice]

        return choice_device

    """
        A function gets an argument to return what type of system the machine is using. If the argument is
        'OS', it will return Windows, Linux or OSX, and the argument is 'distro', it will return the Linux
        distribution being used.
    """
    def get_system(self, p_type):
        if p_type.lower() == 'os':
            from sys import platform
            if platform == "linux" or platform == "linux2":
                check_sys = 'linux'
            else:
                self.printColor('print', self._error,
                                'System not compatible with this script. Use only Linux.')
                check_sys = None
                exit(1)
        elif p_type.lower() == 'distro':
            import platform
            check_sys = str(platform.dist()[0])
        else:
            raise Exception('Error check system.')
        return check_sys

    """ Select partitions """
    def select_type_partition(self):
        # print('Select the partition type that the system is installed on:')
        self.printColor('print', self._header, 'Select the partition type that the system is installed on:')
        opt = True
        while opt:
            choice = input(f"""
1: Ext3/Ext4
2: {self.config['crypto_type'].title().replace('_', ' (')})
3: Quit

\033[95m→ Please enter your choice (1-3): \033[0m""")

            try:
                if choice == "1":
                    opt = False
                    type_partition = 'ext'
                elif choice == "2":
                    opt = False
                    type_partition = self.config['crypto_type']
                elif choice == "3":
                    opt = False
                    return self.printColor('print', self._warning, 'Aborted by user.')
                else:
                    self.printColor('print', self._error, 'Option invalid!')
                    opt = True
            except Exception as e:
                return print('Error!.', e)
            except KeyboardInterrupt as ki:
                return print('Interrupt by user.', ki)

        return type_partition

    def open_os_release():
        pass

    """
        Function to mount the partition to be recovered by Grub.
    """
    def mount_partition(self, device_type):
        import sh
        from os.path import isfile
        from subprocess import check_output, STDOUT

        try:
            shell_command = '''sudo blkid | grep ''' + device_type + '''| awk '{print $1}' | cut -d":" -f1'''
            devices_output = check_output(shell_command, shell=True, stderr=STDOUT,
                                          universal_newlines=True).splitlines()
        except Exception:
            return None

        if device_type == 'ext':
            for partition in devices_output:
                sh.sudo.mount(partition, self.config["mount_dir"], _fg=True)
                if isfile(self.config["mount_dir"] + '/etc/os-release'):

                    content_os_release = sh.cat(self.config["mount_dir"] + '/etc/os-release')
                    dict_os_release = dict([i.split('=') for i in content_os_release.strip().split('\n')])
                    distro_mounted = dict_os_release['NAME'].replace('"', '')

                    if distro_mounted == self.get_system('distro'):
                        try:
                            sh.sudo.mount("--bind", "/dev", self.config['mount_dir'] + "/dev", _fg=True)
                            sh.sudo.mount("--bind", "/dev/pts", self.config['mount_dir'] + "/dev/pts",
                                          _fg=True)
                            sh.sudo.mount("--bind", "/proc", self.config['mount_dir'] + "/proc", _fg=True)
                            sh.sudo.mount("--bind", "/sys", self.config['mount_dir'] + "/sys", _fg=True)
                        except Exception as e:
                            print('Error in performing assemblies.', e)
                            sh.sudo.umount("-R", self.config['mount_dir'], _fg=True)
                        break
                    elif distro_mounted != self.get_system('distro'):
                        sh.sudo.umount(self.config['mount_dir'], _fg=True)
                        continue
                else:
                    sh.sudo.umount(self.config['mount_dir'], _fg=True)

        elif device_type == self.config['crypto_type']:
            print('partition luks')

    # """ Sudo prompt """
    # def prompt_sudo(self):
    #     import os
    #     from subprocess import check_call
    #     uid = 0
    #     if os.geteuid() != 0:
    #         msg = "[sudo] password for %u:"
    #         uid = check_call("sudo -v -p '%s'" % msg, shell=True)
    #     return uid
    # """ Blkid """
    # def blkid(self):
    #     import os
    #     from subprocess import check_call
    #     uid = 0
    #     if os.geteuid() != 0:
    #         msg = "[sudo] password for %u:"
    #         uid = check_call("sudo blkid | grep ext | awk \
    #         '{print $1}' | cut -d\":\" -f1 '%s'" % msg, shell=True)
    #     return print(uid)

    """
        Function to store the functions responsible for the script requirements.
    """
    def requeriments(self):
        self.python_version_required(self.config['python_version'])
        self.modules_external(self.config['modules'])
        self.get_system('os')

    """
        Main function that starts the processes.
    """
    def main(self):
        self.requeriments()
        """ Start """
        args = self.menu_args()
        if args.command == 'device':
            self.mount_partition(self.select_type_partition())
            self.select_device()


if __name__ == '__main__':
    recover_grub = Engine()
    recover_grub.main()
