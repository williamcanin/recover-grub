#!/bin/bash
#
# Information:
#
# ******************************************************************************
# Type: Shell Script
# Description: Mount partition Arch Linux and Recover the Grub on Arch Linux
# Script Name: Recover Grub
# Project URL: https://github.com/williamcanin/recover-grub.git
# URL Script: http://git.io/recover-grub

# Author: William C. Canin
#   Contacts:
#   E-Mail: william.costa.canin@gmail.com
#   WebSite: https://williamcanin.guthub.io
#   GitHub: https://github.com/williamcanin


# BEGIN
#
#### CONFIG ####
# Note: This block is modified automatically according to the execution of the script. ###
MOUNT_STATUS="true"
#
##### Global variables ####
appname="Recover Grub"
appscript="recover-grub"
version="1.2.2"
PS3="Enter option: "
dir_mount="/mnt"
name_crypto_open="filesystem"
crypto_type="crypto_LUKS"
#
#### Functions ####

# Function for messages / colors.
function _msg_header_() {
  printf "\e[0;36m→ %s\e[0m$2" "$1"
}

function _msg_reply_() {
  printf "\e[0;36m→ %s\e[0m$2" "$1"
}

function _msg_finish_() {
  printf "\e[0;32m✔ %s\e[0m\n" "$@"
}

function _msg_warning_() {
  printf "\e[0;33m⚠ %s\e[0m\n" "$@"
}

function _msg_error_() {
  printf "\e[0;31m✖ %s\e[0m\n" "$@"
}

# Function welcome.
function _welcome(){
printf "\e[0;34m

   ---------------------------------------------------------
  |         Welcome - ${appname} - Version ${version}          |
   ---------------------------------------------------------
  | The ${appname} will perform the upgrade and           |
  | installation of Grub in Linux.                          |
  | You will be guided by ${appname} to perform all       |
  | procedures.                                             |
  |---------------------------------------------------------|

\e[0m"
}

# Function show credits.
function _credits(){
cat << EOT

   ---------------------------------------------------------
  |               ${appname} - Version ${version}              |
   ---------------------------------------------------------
  |                         Credits:                        |
  |                                                         |
  |           Author: William da Costa Canin                |
  |           E-Mail: william.costa.canin@gmail.com         |
  |           Website: https://williamcanin.me              |
  |           GitHub: https://github.com/williamcanin       |
  |           Locale: Brazil - SP                           |
  |                                                         |
  |                                                         |
  |    ${appname} © 2015-$(date +%Y) - All Right Reserved.       |
  |    Doc: http://github.com/williamcanin/recover-grub     |
  |---------------------------------------------------------|

EOT
}

# Function show help.
function _help(){
cat << EOT

 ---------------------------------------------------------
|           Help  -  ${appname} - Version ${version}         |
 ---------------------------------------------------------

 Usage: $appscript [options]

  Options:

    device            This is the first option to be chosen.
                      A list of devices will be displayed, choose the
                      device where the Arch Linux is installed to recover
                      the Grub according to the options provided.

    start             Starts the recovery of Grub.
                      This option is enabled, after the use of the
                      'device' option and assemble the system.

    credits           A list of credits of this program.

    help              Output this instructions.

EOT
}

# Spin function for messages in wait.
function _wait_spinner(){
    sleep $1 &
    PID=$!
    i=1
    sp="\-/\-/"
    echo -n ' '
    setterm -cursor off
    printf ' '
    while [ -d /proc/$PID ]
    do
        printf "\b${sp:i++%${#sp}:1}"
    done
    printf "\n"
    setterm -cursor on
}

# Function check if an element exist in a string.
function _contains_element() {
    for e in "${@:2}"; do [[ $e == $1 ]] && break; done;
}

# Function for change block CONFIG.
function _config_change(){
    sed -i "s|^MOUNT_STATUS=.*|MOUNT_STATUS=\"$1\"|g" $0
}

# Function to select the partition type. 
function _select_type_partition(){
    _msg_header_ "Select the partition type that the system is installed on:" "\n"
    select type_device in "ext" "${crypto_type}"; do
        if _contains_element "${type_device}" "ext" "${crypto_type}"; then
            break
        else
            printf "Invalid option \n"
        fi
    done
}

# Function mount bind ('/dev', '/dev/pts', '/proc', '/sys').
function _mount_bind(){
    _msg_warning_ "Mount '/dev', '/dev/pts', '/proc', '/sys'..."
    mount --bind /dev $1/dev
    mount --bind /dev/pts $1/dev/pts
    mount --bind /proc $1/proc
    mount --bind /sys $1/sys    
    _msg_finish_ "Done!"
}


# Function to enter and notify that entered the chroot.
function _chroot_open(){
    _msg_warning_ "Attention! Run the following command to start the recovery:"
    _msg_warning_ "${appscript} start"
    _msg_header_ "Press ENTER to enter the assembled system!" "\n"
    read    
    # Enter system Arch Linux found
    chroot ${dir_mount} /bin/bash   
}

# Function for umount all partition.
function _umount_partition(){
    umount -R $1
    _msg_finish_ "Dismantling made partitions!"
    _msg_finish_ "Successfully restructured Grub! No error!"
    _msg_warning_ "Now you can restart the machine with the command: reboot"
    rm -f $0
}

# Function copied script Recover Grub for /usr/bin of the assembled system.
function _copied_script_bin(){
    cp -f $0 $1/usr/bin
    chmod +x $1/usr/bin/${appscript}
}

# Function select device.
function _select_sd_hd_vd(){
  _msg_header_ "Select the device in which the Grub will be recovered." "\n"
  sd_hd_vd_list=(`lsblk -d | awk '{print "/dev/" $1}' | grep 'sd\|hd\|vd'`);
  _msg_header_ "List devices options:" "\n"
  select sd_hd_vd_choice in "${sd_hd_vd_list[@]}"; do
    if _contains_element "${sd_hd_vd_choice}" "${sd_hd_vd_list[@]}"; then
      break
    else
      _msg_error_ "Invalid option"
    fi
  done
}

# Function to select encrypted partitions (crypto_LUKS).
function _select_mount_partition_crypto(){
    devices_list=( $(blkid | grep "$1" | awk '{print $1}' | cut -d":" -f1) )
    if [[ -n $devices_list ]]; then
        printf "\e[0;34m

   ---------------------------------------------------------
  |            Assembly of encrypted partition.             |
   ---------------------------------------------------------
  | The encrypted partition mount requires you to know      |
  | which device is encrypted.                              |
  | A list below will be displayed, just choose the         |
  | encrypted partition that the filesystem installed.      |
  |---------------------------------------------------------|

        \e[0m"    
        echo
        _msg_header_ "Select one of the encrypted partitions in the list:" "\n"
        select device in "${devices_list[@]}"; do
            if _contains_element "${device}" "${devices_list[@]}"; then
                # Open partition crypted
                echo "cryptsetup open ${device} ${name_crypto_open}"
                # Mount partition crypted
                echo "mount /dev/mapper/${name_crypto_open} $2"
                if [[ -f "$2/etc/os-release" ]]; then
                    distro_name=$(cat $2/etc/os-release | grep ^NAME | cut -d"=" -f2 | cut -d"\"" -f2)
                    if [[ "$distro_name" == "Arch Linux" ]]; then
                        printf "Wait" 
                        _wait_spinner "5"
                        _msg_finish_ "${distro_name} found!"
                        _mount_bind "${dir_mount}"
                        _config_change "true"
                        _copied_script_bin "${dir_mount}"
                        _chroot_open
                        _umount_partition "${dir_mount}"
                        exit 0
                    else
                        umount -R $2          
                    fi
                else
                    umount -R $2       
                fi 

                break
            else
                _msg_error_ "Invalid option"
            fi
        done

    else
        _msg_finish_ "No device of type '$1' was found. ${appname} can not continue. :("
        exit 1
    fi    
}

# Function to mount partitions of type EXT recursively.
function _select_mount_partition_ext(){
    devices_list=( $(blkid | grep "$1" | awk '{print $1}' | cut -d":" -f1) )
    if [[ -n $devices_list ]]; then
        for partition in ${devices_list}; do
            mount $partition $2
            if [[ -f "$2/etc/os-release" ]]; then
                distro_name=$(cat $2/etc/os-release | grep ^NAME | cut -d"=" -f2 | cut -d"\"" -f2)
                if [[ "$distro_name" == "Arch Linux" ]]; then
                    printf "Wait" 
                    _wait_spinner "5"
                    _msg_finish_ "${distro_name} found!"
                    _mount_bind "${dir_mount}"
                    _config_change "true"
                    _copied_script_bin "${dir_mount}"
                    _chroot_open               
                    _umount_partition "${dir_mount}"
                    exit 0
                else
                    umount -R $2          
                fi
            else
                umount -R $2       
            fi
        done
    else
        _msg_finish_ "No device of type '$1' was found. ${appname} can not continue. :("
        exit 1
    fi
}

# Function started mount.
function _start_mount(){
    _select_type_partition
    if [[ $type_device == "${crypto_type}" ]]; then
        _select_mount_partition_crypto "${crypto_type}" "${dir_mount}"
    else
        _select_mount_partition_ext "ext" "${dir_mount}"
    fi
}

# Function Recover Grub.
function _recover_grub(){
    if [[ ${MOUNT_STATUS} == "true" ]]; then
        _msg_header_ "The ${appname} will perform the upgrade and installation of Grub" "\n"
        echo
        printf "Wait" 
        _wait_spinner "3"
        _select_sd_hd_vd
        grub-mkconfig -o /boot/grub/grub.cfg    
        grub-install ${sd_hd_vd_choice}
        _msg_finish_ "Successfully restructured Grub!  ..."
        _msg_warning_ "We're almost done...Use command: exit"
        rm -f /usr/bin/${appscript}
        exit 0
    else
        _msg_error_ "You can only start Grub recovery if everything is set up! Use the 'device' option first."
        exit 1
    fi 
}

##### Menu ####

# Script run root.
(( UID > 0 )) && { _msg_error_ "This script runs only with root user."; exit 1; }

case "$1" in
    device)
        _welcome
        _start_mount
    ;;
    start)
        _recover_grub
    ;;
    credits)
        _credits
    ;;
    help)
        _help
    ;;
    *)
        _msg_error_ "Option not allowed! Use one of the options below."
        _help
    ;;
esac
exit 0

#
# END 
