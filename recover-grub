#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Information:

# ******************************************************************************
# Type: Python 3
# Description: Mount partition Linux and Recover the Grub on Linux
# Script Name: Recover Grub
# Project URL: https://github.com/williamcanin/recover-grub.git
# URL Script: http://git.io/recover-grub

# Tools used:
#   Atom Editor:
#       - wrap-guide (Preferred Line Lenght: 115)
#       - atom-beautify
#       - autocomplete-python
#       - MagicPython
#       - linter
#       - linter-flake8 (Max Line Length: 115)

# Author: William C. Canin
#   Contacts:
#   E-Mail: william.costa.canin@gmail.com
#   WebSite: https://williamcanin.github.io
#   GitHub: https://github.com/williamcanin

# ******************************************************************************


class RecoverGrub_UI:
    def __init__(self):
        self._header = '\033[36mⓘ  '
        self._warning = '\033[93m⚠  '
        self._reply = '\033[95m→ '
        self._okgreen = '\033[92m✔ '
        self._error = '\033[91m✖ '
        self._end = '\033[0m'

        # Design text using figlet. Install: $ sudo apt install figlet
        # Usage: $ figlet <Text>
        print("""
\033[36mWelcome to\033[0m
\033[93m ____                               ____            _
|  _ \ ___  ___ _____   _____ _ __ / ___|_ __ _   _| |__
| |_) / _ \/ __/ _ \ \ / / _ \ '__| |  _| '__| | | | '_ \\
|  _ <  __/ (_| (_) \ V /  __/ |  | |_| | |  | |_| | |_) |
|_| \_\___|\___\___/ \_/ \___|_|   \____|_|   \__,_|_.__/\033[0m
                                       since 2018 © v{}
        """.format(self.config['appversion']))

    def printColor(self, type, color, message, options='') -> str:
        if type == 'print':
            return print(f'{color}{message}' + self._end)
        elif type == 'input':
            return input(f'{color}{message}' + self._end)
        elif type == 'except':
            return print(f'\n{color}{message}' + self._end, options)
        else:
            raise print('Error in first argument in "PrintColor"')


class RecoverGrub_Start:
    def __init__(self):
        print('Ok.')


class RecoverGrub_Engine(RecoverGrub_UI):

    config = {'appname': 'Recover Grub',
              'appscript': 'recover-grub',
              'appconfig': '.rgrub.json',
              'python_version': 3,
              'appversion': '3.0',
              'mount_dir': '/mnt/temp',
              'name_crypto_open': 'filesystem2',
              'crypto_type': 'crypto_LUKS'
              }

    def verify_root(self, uid):
        """
            Function to check if script is running with superuser.
        """
        from os import geteuid

        if geteuid() != uid:
            self.printColor('print', self._warning,
                            self.config['appname'] + ' can only be run with superuser (root). Aborted!')
            exit(0)

    def select_device(self) -> str:
        """
            A function that converses with the user to make the selection of the devices of the machine, for
            the assembly.
        """
        self.printColor('print', self._header, 'Select the device in which the Grub will be recovered')

        try:
            while True:
                print()
                for index, item in enumerate(self.get_device(), start=1):
                    print(f'{index}: {item}')
                index_quit = index + 1
                print(f'{index_quit}: Quit\n')

                choice = self.printColor('input', self._reply, 'Please enter your choice (1-' +
                                         str(index + 1) + '): ')
                if not choice.isdigit():
                    self.printColor('print', self._error, 'Enter numbers only')
                    continue
                elif int(choice) == index_quit:
                    return str(self.printColor('print', self._warning, 'Aborted by user'))
                    break
                elif int(choice) > (index_quit):
                    self.printColor('print', self._error, 'Option invalid')
                    continue
                else:
                    choice = (int(choice) - 1)
                    choice_device = self.get_device()[int(choice)]
                    return choice_device
                    break
        except Exception as err:
                return self.printColor('except', self._warning, 'There was some error making the choice.', err)
        except KeyboardInterrupt as ki:
                return self.printColor('except', self._warning, 'Interrupt by user using Ctrl+C.', ki)

    def copyfiles_rg(self, file):
        """
            Function to perform a copy of this same script for the assembled pointer.
        """
        from shutil import copyfile
        from os import chmod
        if file == 'setup':
            pathfile = self.config['mount_dir'] + '/usr/local/bin/' + self.config['appscript']
            copyfile(self.config['appscript'], pathfile)
            chmod(pathfile, 0o775)
        elif file == 'config':
            pathfile = self.config['mount_dir'] + '/etc/' + self.config['appconfig']
            copyfile(self.config['appconfig'], pathfile)
            chmod(pathfile, 777)

    def create_config(self, mounted, recovered):
        """
            Function to create .json configuration file.
        """
        from json import dump
        from os.path import isfile
        if not isfile(self.config['appconfig']):
            data = {"status": {"mounted": mounted, "recovered": recovered}, "partition": self.select_device()}
            with open(self.config['appconfig'], 'w') as outfile:
                dump(data, outfile)

    def read_config(self) -> str:
        """
            Function to read .json configuration file.
        """
        from json import load
        from os.path import isfile
        if isfile(self.config['appconfig']):
            with open(self.config['appconfig']) as outfile:
                data = load(outfile)
        return data

    def python_version_required(self, p_version: int):
        """
            Function to check the version of Python that this script uses.
        """
        import sys
        try:
            if sys.version_info[0] < p_version:
                raise Exception('Must be using Python {}'.format(p_version))
        except Exception as err:
            print('Error!', err)
            exit(1)

    def menu_args(self):
        """
            This function will return the parameters passed in the execution of the script.
        """
        from argparse import ArgumentParser
        try:
            parser = ArgumentParser(prog='prog',
                                    usage='usage',
                                    description='desc')
            parser.add_argument('command', action='store',
                                type=str, default='--help')
            args = parser.parse_args()
            return args

        except Exception as err:
            return self.printColor('except', self._warning, 'Error in passing arguments..', err)

    def get_device(self):
        """
            A function that returns a list of SD / HS / SSD devices on the machine.
        """
        from subprocess import check_output, STDOUT
        command = '''lsblk -d | awk '{print "/dev/" $1}' | grep 'sd\\|hd\\|vd' '''
        out = check_output(command, shell=True, stderr=STDOUT, universal_newlines=True).split()
        return out

    def get_system(self, p_type):
        """
            A function gets an argument to return what type of system the machine is using. If the argument is
            'OS', it will return Windows, Linux or OSX, and the argument is 'distro', it will return the Linux
            distribution being used.
        """
        if p_type.lower() == 'os':
            from sys import platform
            if platform == "linux" or platform == "linux2":
                check_sys = 'linux'
            else:
                check_sys = str(self.printColor('print', self._error,
                                                'System not compatible with this script. Use only Linux.'))
                exit(1)
        elif p_type.lower() == 'distro':
            import platform
            check_sys = str(platform.dist()[0])
        else:
            raise Exception('Error check system.')
        return check_sys

    def select_type_partition(self):
        """
            Select partitions
        """
        self.printColor('print', self._header, 'Select the partition type that the system is installed on:')
        while True:
            try:
                choice = input(f"""
1: Ext3/Ext4
2: {self.config['crypto_type'].title().replace('_', ' (')})
3: Quit

\033[95m→ Please enter your choice (1-3): \033[0m""")

                if choice == "1":
                    type_partition = 'ext'
                    break
                elif choice == "2":
                    type_partition = self.config['crypto_type']
                    break
                elif choice == "3":
                    return str(self.printColor('print', self._warning, 'Aborted by user.'))
                    break
                else:
                    self.printColor('print', self._error, 'Option invalid!')
                    continue
            except Exception as err:
                return self.printColor('except', self._warning, 'Something unexpected happened :(', err)
            except KeyboardInterrupt as ki:
                return self.printColor('except', self._warning, 'Interrupt by user using Ctrl+C.', ki)

        return type_partition

    def mount_partition(self, device_type):
        """
            Function to mount the partition to be recovered by Grub.
        """
        from os.path import isfile
        from subprocess import check_output, STDOUT

        try:
            shell_command = '''blkid | grep ''' + device_type + '''| awk '{print $1}' | cut -d":" -f1'''
            devices_output = check_output(shell_command, shell=True, stderr=STDOUT,
                                          universal_newlines=True).splitlines()
        except Exception as err:
            return self.printColor('except', self._error, 'There was an error using superuser command.', err)
        except KeyboardInterrupt as ki:
            return self.printColor('except', self._warning, 'Interrupt by user using Ctrl+C.', ki)

        if device_type == 'ext':
            for partition in devices_output:
                if isfile(self.config["mount_dir"] + '/etc/os-release'):
                    self.printColor('print', self._warning, 'A mounted partition already exists in ' +
                                    self.config["mount_dir"] + '. Use the "sudo umount ' +
                                    self.config["mount_dir"] + '" command to unmount, and re-run the ' +
                                    self.config["appname"] + '.')
                    break
                else:
                    check_output(['mount', partition, self.config["mount_dir"]])
                    if isfile(self.config["mount_dir"] + '/etc/os-release'):
                        content_os_release = check_output(['cat', self.config["mount_dir"], '/etc/os-release'],
                                                          stderr=STDOUT, universal_newlines=True)
                        dict_os_release = dict([i.split('=') for i in content_os_release.strip().split('\n')])
                        distro_name = dict_os_release['NAME'].replace('"', '')
                        distro_pretty_name = dict_os_release['PRETTY_NAME'].replace('"', '')

                        if distro_name == self.get_system('distro'):
                            try:
                                check_output(['mount', '--bind', '/dev', self.config["mount_dir"], '/dev'])
                                check_output(['mount', '--bind', '/dev/pts', self.config["mount_dir"], '/dev/pts'])
                                check_output(['mount', '--bind', '/proc', self.config["mount_dir"], '/proc'])
                                check_output(['mount', '--bind', '/sys', self.config["mount_dir"], '/sys'])
                                self.printColor('print', self._okgreen, 'Partition containing "' +
                                                distro_pretty_name + '" was found and mounted on "' +
                                                self.config['mount_dir'] + '".')
                                self.create_config('true', 'false')
                                self.copyfiles_rg('setup')
                                self.copyfiles_rg('config')
                                self.printColor('print', self._warning, 'You are now in the chroot. Run ' +
                                                '\033[36m"recover-grub start"\033[93m to start Grub recovery.')
                                # Enter in Chroot.
                                check_output(['chroot', self.config["mount_dir"], '/bin/bash'])
                                # Exit chroot.
                                check_output(['umount', '-R', self.config["mount_dir"]])
                            except Exception as err:
                                self.printColor('except', self._warning, 'Error in performing assemblies.', err)
                                check_output(['umount', '-R', self.config["mount_dir"]])
                            break
                        elif distro_name != self.get_system('distro'):
                            check_output(['umount', self.config["mount_dir"]])
                            continue
                    else:
                        check_output(['umount', self.config["mount_dir"]])

        elif device_type == self.config['crypto_type']:
            for partition in devices_output:
                if isfile(self.config["mount_dir"] + '/etc/os-release'):
                    self.printColor('print', self._warning, 'A mounted partition already exists in ' +
                                    self.config["mount_dir"] + '. Use the "sudo umount ' +
                                    self.config["mount_dir"] + '" command to unmount, and re-run the ' +
                                    self.config["appname"] + '.')
                    break
                else:
                    # cryptsetup
                    try:
                        check_output('cryptsetup open ' + partition + ' ' + self.config['name_crypto_open'],
                                     shell=True, stderr=STDOUT, universal_newlines=True)
                    except KeyboardInterrupt as ki:
                        return self.printColor('except', self._warning, 'Interrupt by user using Ctrl+C.', ki)
                    if not isfile(self.config["mount_dir"] + '/etc/os-release'):
                        print('Not system.')

    def main(self):
        """
            Main function that starts the processes.
        """
        # Requeriments
        self.python_version_required(self.config['python_version'])
        self.get_system('os')
        self.verify_root(0)

        args = self.menu_args()
        if args.command == 'device':
            self.create_config('false', 'false')
            if self.read_config()['status']['mounted'] == 'true':
                self.printColor('print', self._warning, 'The partition is already mounted. I use the command to ' +
                                'recover.')
                exit(0)
            elif self.read_config()['status']['mounted'] == 'false':
                # self.copyfiles_rg()
                # self.select_device() # not
                self.mount_partition(self.select_type_partition())


if __name__ == '__main__':
    recover_grub = RecoverGrub_Engine()
    recover_grub.main()
