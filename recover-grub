#!/bin/bash
#
# Information:
#
# ******************************************************************************
# Type: Shell Script
# Description: Mount partition Arch Linux and Recover the Grub on Arch Linux
# Script Name: Recover Grub
# Release Status: 1.1.1
# Project URL: https://github.com/williamcanin/recover-grub.git
# URL Script: http://git.io/recover-grub

# Author: William C. Canin
#   Contacts:
#   E-Mail: william.costa.canin@gmail.com
#   WebSite: http://williamcanin.guthub.io
#   GitHub: https://github.com/williamcanin


# License:
# The MIT License (MIT) for Recover Grub

# Copyright (c) 2015-2016 William C. Canin <william.costa.canin@gmail.com>

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
# ******************************************************************************
#

# Begin

# Constants
#
mount_dir="/mnt"
email="william.costa.canin@gmail.com"
website="http://williamcanin.com"
github="https://github.com/williamcanin"
program_name="Recover Grub"
executable="recover-grub"
year_current="$(date +%Y)"
prompt1="Enter your option: "
# COLORS
Bold=$(tput bold)
Underline=$(tput sgr 0 1)
None=$(tput sgr0)
# Regular Colors
Red=$(tput setaf 1)
Green=$(tput setaf 2)
Yellow=$(tput setaf 3)
Blue=$(tput setaf 4)
Purple=$(tput setaf 5)
Cyan=$(tput setaf 6)
White=$(tput setaf 7)
# Bold
BRed=${Bold}$(tput setaf 1)
BGreen=${Bold}$(tput setaf 2)
BYellow=${Bold}$(tput setaf 3)
BBlue=${Bold}$(tput setaf 4)
BPurple=${Bold}$(tput setaf 5)
BCyan=${Bold}$(tput setaf 6)
BWhite=${Bold}$(tput setaf 7)

# Messages
Error="[${Red} Error ${None}]"
Warning="[${Yellow} Warning ${None}]"
Info="[${Cyan} Info ${None}]"
Ok="[${Green} Ok ${None}]"
Wait="[${White} Wait ${None}]"

# Config - Program manipulation
device_choose="/dev/sda"
mount_device_status="false"
mount_mnt_status="false"

# Variables
version="1.1.1"


# Function show Credits
function _credits(){
cat << EOT

   ---------------------------------------------------------
  |               ${program_name} - Version ${version}              |
   ---------------------------------------------------------
  |                         Credits:                        |
  |                                                         |
  |           Author: William da Costa Canin                |
  |           E-Mail: $email         |
  |           Website: $website              |
  |           GitHub: $github       |
  |           Locale: Brazil - SP                           |
  |                                                         |
  |                                                         |
  |    ${program_name} Â© 2015-$year_current - All Right Reserved.       |
  |    Doc: http://github.com/williamcanin/recover-grub     |
  |---------------------------------------------------------|

EOT
}

# Function show help
function _help(){
cat << EOT

 ---------------------------------------------------------
|           Help  -  ${program_name} - Version ${version}         |
 ---------------------------------------------------------

 Usage: $executable [options]

  Options:

    device            Find the partition where the Arch Linux is mounted
                      and mounts.
                      A list of devices will be displayed, choose the
                      device where the Arch Linux is installed to recover
                      the Grub.

    start             Starts the recovery of Grub.
                      This option is enabled, after the use of the
                      'device' option and assemble the system.

    credits           A list of credits of this program.

    help              Output this instructions.

EOT
}


# Spin function for messages in wait
function _wait_spinner(){
  sleep $1 &
  PID=$!
  i=1
  sp="/-\|"
  echo -n ' '
  setterm -cursor off
  printf ' '
  while [ -d /proc/$PID ]
  do
    printf "\b${sp:i++%${#sp}:1}"
  done
  printf "\n"
  setterm -cursor on
}

# Checks whether the Grub Recover program will run on a Arch Linux distribution
function _check_current_system(){
  current_system=$(cat /etc/os-release | grep ^NAME | cut -d"=" -f2 | cut -d"\"" -f2)
  if [[ $current_system != "Arch Linux" ]]; then
    printf "${Error} ${Red} You can not run this program for Fedora at the moment only for Arch Linux.${None}\n"
    exit 1
  fi
}

# Function restart variables config - This development
function _restart_config(){
  sed -i "s|^device_choose=.*|device_choose=\"none\"|g" $0
  sed -i "s|^mount_device_status=.*|mount_device_status=\"false\"|g" $0
  sed -i "s|^mount_mnt_status=.*|mount_mnt_status=\"false\"|g" $0
}

# Script shutdown function
function _finishing(){
  umount -R $mount_dir
  printf "${Ok} Dismantling made partitions!\n"
  printf "${Ok} ${White}Successfully restructured Grub! No error! \n${None}"
  printf "${Ok} ${White}Now you can restart the machine with the command: ${BBlue}reboot \n${None}"
  rm -f $0
}

# Function check if an element exist in a string
function _contains_element() {
    for e in "${@:2}"; do [[ $e == $1 ]] && break; done;
}

# Function select device
function _select_device(){
  printf "${Info} ${BCyan} Select the device in which the Grub will be recovered. ${None}\n\n"
  devices_list=(`lsblk -d | awk '{print "/dev/" $1}' | grep 'sd\|hd\|vd'`);
  PS3="$prompt1"
  printf "List devices options:\n\n"
  select device in "${devices_list[@]}"; do
    if _contains_element "${device}" "${devices_list[@]}"; then
      break
    else
      printf "${Error} ${Red} Invalid option ${None}\n"
    fi
  done
  boot_mountdevice="$device"
}


# Function responsible for capturing the partition of Arch Linux and assemble.
function _mount_device(){
  _check_current_system
  _select_device
  if [[ $mount_device_status == "false" ]]; then
    # Array number of partitions
    npartitions=$(lsblk -f | grep ext | cut -d"e" -f1 | cut -d"a" -f2 | sed ':a;$!N;s/\n//;ta;'n)
    for partition in ${npartitions}; do
      mount $boot_mountdevice$partition $mount_dir
      if [[ -f "$mount_dir/etc/os-release" ]]; then
        distro_name=$(cat $mount_dir/etc/os-release | grep ^NAME | cut -d"=" -f2 | cut -d"\"" -f2)
        if [[ "$distro_name" == "Arch Linux" ]]; then
          sed -i "s|^mount_device_status=.*|mount_device_status=\"true\"|g" $0
          printf "${Ok} ${White}$distro_name device found!${None}\n"
          printf "${Ok} ${White}Files copied done.${None}\n"
          mount --bind /dev $mount_dir/dev
          mount --bind /dev/pts $mount_dir/dev/pts
          mount --bind /proc $mount_dir/proc
          mount --bind /sys $mount_dir/sys
          printf "${Ok} ${White}Mounts directories done.${None}\n"
          printf "${Wait} ${White}Finding the $distro_name system ${None}"
          _wait_spinner "5"
          printf "${Ok} ${White} $program_name system found! ${None}\n"
          printf "${Warning} ${Yellow} Attention! Run the following command to start the recovery: ${None}\n"
          printf "${Blue} $executable start ${None}\n"
          printf "${White} Press ENTER to enter the assembled system! ${None}\n"
          read
          sed -i "s|^device_choose=.*|device_choose=\"$boot_mountdevice\"|g" $0
          cp -f $0 $mount_dir/usr/bin
          chmod +x $mount_dir/usr/bin/$executable
          # Enter system Arch Linux found
          chroot $mount_dir /bin/bash
          # Load function _finishing
          _finishing
          exit 0
        else
          umount $mount_dir
        fi
      else
        umount $mount_dir
      fi
    done

    # Array qtde of partitions
    qtdpartitions=( $(lsblk -f | grep ext | cut -d"e" -f1 | cut -d"a" -f2 | sed ':a;$!N;s/\n//;ta;'n) )
    qtdpartitions_refactored="$(expr ${#qtdpartitions[@]} - 1)"
    for (( x = 0; x < ${#qtdpartitions[@]}; x++ )); do
      if [[ $x == $qtdpartitions_refactored ]] && [[ ! -f "$mount_dir/etc/os-release" ]]; then
        printf "${Error} ${White} Sorry, but it seems that the mounted partitions did not return the file: \"${mount_dir}/etc/os-release\" :(\n${None}"
        exit 1
      fi
    done

  else
    printf "${Warnin} ${White}Mounting settings have been made. Run recover Grub with the command:${None}\n"
    printf "${Blue} $executable start ${None}\n"
    exit 0
  fi
}

# Function that initiates recovery
function _recover_grub_start(){
  if [[ $device_choose != "none" ]]; then
    printf "${Wait} ${White}The $program_name will perform the upgrade and installation of Grub ${None}"
    _wait_spinner "5"
    grub-mkconfig -o /boot/grub/grub.cfg
    grub-install $device_choose
    printf "${Ok} ${White}Successfully restructured Grub! We're almost done ... ${None}\n"
    printf "${Warning} ${White}Use command: exit ${None}\n"
    rm -f /usr/bin/$executable
    exit 0
  else
    printf "${Error} ${White}There was an error in the device choice before entering the Arch Linux.${None}\n"
    exit 1
  fi
}


_select_device
# echo "mount $boot_mountdevice$partition $mount_dir"
# Menu
# case "$1" in
#    device)
#       _mount_device
#     ;;
#    start)
#     _recover_grub_start
#    ;;
#    credits)
#     clear
#     _credits
#    ;;
#    help)
#     _help
#    ;;
#   # This option is not listed in help for reasons that will be for administration.
#     restartc)
#      _restart_config
#     ;;
#     *)
#       printf "\n${Warning} ${White}Option not allowed! Use one of the options below. ${None}\n"
#       _help
#     ;;
# esac
# exit 0

# End